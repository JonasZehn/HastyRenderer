#version 460
#extension GL_EXT_ray_query : require
#extension GL_EXT_scalar_block_layout : require
#extension GL_EXT_nonuniform_qualifier : require

#define HASTY_OUT(type) out type
#define HASTY_INOUT(type) inout type

struct Material {
	vec3 emission;
	float specular;
	float anisotropy;
	float transmission;
	float indexOfRefraction;
};

struct TriangleData {
	uint vertexIndices[3];
	uint materialIndex;
	vec2 textureCoordinates[3];
	int normalIndices[3];
};

layout(local_size_x = 4, local_size_y = 4, local_size_z = 1) in;

layout(binding = 0, set = 0) uniform accelerationStructureEXT tlas;

layout(binding = 1, set = 0, scalar) buffer Vertices
{
	vec3 vertices[];
};
layout(binding = 2, set = 0, scalar) buffer Triangles
{
	TriangleData triangles[];
};
layout(binding = 3, set = 0, scalar) buffer Normals
{
	vec3 normals[];
};

layout(binding = 5, set = 0, scalar) buffer Materials
{
	Material materials[];
};

// https://github.com/SaschaWillems/Vulkan/blob/master/examples/descriptorindexing/descriptorindexing.cpp
// https://github.com/SaschaWillems/Vulkan/tree/master/data/shaders/glsl/descriptorindexing

layout(binding = 6, set = 0) uniform sampler2D albedoTextures[];
layout(binding = 7, set = 0) uniform sampler2D metallicTextures[];
layout(binding = 8, set = 0) uniform sampler2D roughnessTextures[];

layout(binding = 9, set = 0, scalar) buffer RandomInputState
{
	uint randomInputState[];
};

layout(binding = 10, scalar) uniform Camera {
	vec3 position;
	float fovSlope;
	vec3 forward;
	vec3 right;
	vec3 up;
	float apertureSize;
	float focalDistance;
	int numBlades;
	float bladeRotation;
} camera;

layout(binding = 11, set = 0, rgba32f) uniform image2D colorImage;
layout(binding = 12, set = 0, rgba32f) uniform image2D normalImage;
layout(binding = 13, set = 0, rgba32f) uniform image2D albedoImage;

layout( push_constant, scalar ) uniform PushConstants // guarantueed to be at least 128 bytes
{
	int nSamples;
	vec3 backgroundColor;
};

//////// VMath.h

const float Pi = 3.14159265358979323846;
const float InvPi = 0.318309886183790671;
	
float square(float f){ return f*f; }

float norm(vec2 f){ return sqrt(dot(f,f)); }
float norm(vec3 f){ return sqrt(dot(f,f)); }
float norm(vec4 f){ return sqrt(dot(f,f)); }

float normSq(vec3 v){ return dot(v, v); }

vec3 orthonormalized(vec3 v1Normalized, vec3 v2)
{
	vec3 result = v2 - dot(v2, v1Normalized) * v1Normalized;
	return normalize(result);
}

vec3 anyOrthonormal(vec3 v1Normalized)
{
	if (abs(v1Normalized.x) < 0.7f)
	{
		return orthonormalized(v1Normalized, vec3(1.0f, 0.0f, 0.0f));
	}
	else
	{
		return orthonormalized(v1Normalized, vec3(0.0f, 1.0f, 0.0f));
	}
}
vec3 reflectAcross(vec3 outgoing, vec3 N)
{
	return reflect(-outgoing, N); // -outgoing + 2.0f * dot(N, outgoing) * N;
}

struct RotationBetweenTwoVectors{
	float a;
	vec3 b;
	vec3 c;
	vec3 d;
};
RotationBetweenTwoVectors RotationBetweenTwoVectorsConstruct(vec3 vFrom, vec3 vTo)
{
	RotationBetweenTwoVectors result;
	
	float cosAngle = dot(vFrom, vTo);
	float onePlusCosAngle = float(1.0) + cosAngle;
	
	// v_rot = x * cos(angle) + (k sin(angle) cross x + (k sin(angle) )  ( (k sin(angle) ) dot x ) / (1 + cos(angle))
	vec3 kSinAngle = cross(vFrom, vTo);
	bool inversion = abs(onePlusCosAngle) <= 1e-6;
	vec3 kOrthogonal = anyOrthonormal(vFrom); // find rotation axis so we don't invert volume
	
	result.a = inversion ? -1.0 : cosAngle;
	result.b = inversion ? vec3(0.0) : kSinAngle;
	result.c = inversion ? kOrthogonal : kSinAngle;
	result.d = inversion ? (kOrthogonal * 2.0) : (kSinAngle / onePlusCosAngle);
	
	return result;
}
vec3 applyRotation(RotationBetweenTwoVectors rotation, vec3 x)
{
  return x * rotation.a + cross(rotation.b, x) + rotation.c * dot(rotation.d, x);
}

//////// LightRayInfo.h

struct MediumInfo {
	int mediumId;
	vec3 transmittance;
	float IOR;
};
struct LightRay {
	MediumInfo mediumInfo[3]; // only support number of overlapping media
};

//////// Scene.h

struct SurfaceInteraction {
	int primitiveID;
	uint materialIndex;
	vec3 x;
	vec3 normalGeometric;
	vec2 uv;
	vec2 uvInverted;
	vec3 tangent;
	vec3 bitangent;
	vec3 normalShadingDefault;
};


//////// LightRayInfo.cpp

LightRay LightRayConstruct()
{
	LightRay lightRay;
	for(int i=0; i<lightRay.mediumInfo.length(); i++){
		lightRay.mediumInfo[i].mediumId = -1;
	}
	return lightRay;
}
vec3 getTransmittance(LightRay lightRay)
{
	for(int i=0; i<lightRay.mediumInfo.length(); i++){
		if(lightRay.mediumInfo[i].mediumId != -1){
			return lightRay.mediumInfo[i].transmittance;
		}
	}
	return vec3(1.0);
}
float getOutsideIOR(LightRay lightRay, bool fromOutside, int mediumId)
{
	if(fromOutside){
		for(int i=0; i<lightRay.mediumInfo.length(); i++){
			if(lightRay.mediumInfo[i].mediumId != -1){
				return lightRay.mediumInfo[i].IOR;
			}
		}
	} else {
		for(int i=0; i<lightRay.mediumInfo.length(); i++){
			if(lightRay.mediumInfo[i].mediumId != mediumId && lightRay.mediumInfo[i].mediumId != -1){
				return lightRay.mediumInfo[i].IOR;
			}
		}
	}
	return 1.0;
}
void updateMedium(inout LightRay lightRay, bool beforeOutside, bool afterOutside, int mediumId, vec3 mediumTransmittance, float indexOfRefractionMat)
{
	if(beforeOutside && !afterOutside){
		//entering medium
		for(int i=0; i<lightRay.mediumInfo.length(); i++){
			if(lightRay.mediumInfo[i].mediumId == -1){
				lightRay.mediumInfo[i].mediumId = mediumId;
				lightRay.mediumInfo[i].transmittance = mediumTransmittance;
				lightRay.mediumInfo[i].IOR = indexOfRefractionMat;
				break;
			}
		}
	}
	if(!beforeOutside && afterOutside){
		//leaving medium
		for(int i=0; i<lightRay.mediumInfo.length(); i++){
			if(lightRay.mediumInfo[i].mediumId == mediumId){
				lightRay.mediumInfo[i].mediumId = -1;
				break;
			}
		}
	}
}

//////// PathTracing.h

vec3 beersLaw(vec3 transmittance, float d)
{
	if(transmittance == vec3(1.0)) return vec3(1.0); // hot code path

	vec3 result;
	float dRef = 1.0f;
	float invdRef = 1.0f / dRef;
	for(int i = 0; i < 3; i++)
	{
		result[i] = transmittance[i] <= 0.0f ? 0.0f : pow(transmittance[i], invdRef * d); //	exp(logf(transmittance[i]) * (invdRef * d))
	}
	//assertFinite(result);
	return result;
}


//////// Random.h

struct HaltonSequence1 {
	int b;
	int n;
	int d;
};
HaltonSequence1 HaltonSequence1Construct(int b){
	HaltonSequence1 result;
	result.b = b;
	result.n = 0;
	result.d = 1;
	return result;
}
float haltonSequence1Update(inout HaltonSequence1 seq){
	int x = seq.d - seq.n;
	if (x == 1)
	{
		seq.n = 1;
		seq.d *= seq.b;
	}
	else
	{
		int y = seq.d / seq.b;
		while (x <= y)
		{
			y /= seq.b;
		}
		seq.n = (seq.b + 1) * y - x;
	}
	return float(seq.n) / seq.d;
}
struct HaltonSequence2 {
	HaltonSequence1 s1;
	HaltonSequence1 s2;
};
HaltonSequence2 HaltonSequence2Construct(){
	HaltonSequence2 result;
	result.s1 = HaltonSequence1Construct(2);
	result.s2 = HaltonSequence1Construct(3);
	return result;
}
vec2 HaltonSequence2Update(inout HaltonSequence2 seq){
	vec2 result;
	result.x = haltonSequence1Update(seq.s1);
	result.y = haltonSequence1Update(seq.s2);
	return result;
}

struct RNG {
	uint s1;
	uint s2;
	uint s3;
	uint b;
};

// [Maximally equidistributed combined Tausworthe generators, Pierre Lâ€™Ecuyer](https://www.ams.org/journals/mcom/1996-65-213/S0025-5718-96-00696-5/)
uint QuickTausConstruct(uint k, uint q, uint seed){
	uint r = 32 - k;
	uint mask = uint(0xFFFFFFFF) >> r;
	uint A = seed & mask;
	uint B = (((A << q) ^ A) >> k);
	A = A ^ B;
	return A;
}
void QuickTausUpdate(inout uint A, inout uint B, uint k, uint q, uint kMinusS, uint C, uint s)
{
	B = (((A << q) ^ A) >> kMinusS);
	A = (((A & C) << s) ^ B);
}

RNG RNGConstruct(uint seed0, uint seed1, uint seed2){
	RNG result;
	result.s1 = QuickTausConstruct(31, 13, seed0);
	result.s2 = QuickTausConstruct(29, 2, seed1);
	result.s3 = QuickTausConstruct(28, 3, seed2);
	result.b = 0;
	return result;
}
uint RNGUpdate(inout RNG rng)
{
	QuickTausUpdate(rng.s1, rng.b, 31, 13, 19, 4294967294, 12);
	QuickTausUpdate(rng.s2, rng.b, 29, 2, 25, 4294967288, 4);
	QuickTausUpdate(rng.s3, rng.b, 28, 3, 11, 4294967280, 17);
	return rng.s1 ^ rng.s2 ^ rng.s3;
}
float uniform01f(inout RNG rng){
	uint randomNumber = RNGUpdate(rng);
	return randomNumber * 2.3283064365386962890625e-10; // 2^-32
}


//////// BRDF.h 

struct MaterialEvalResult
{
	vec3 fDiffuse;
	vec3 fConcentrated;
	vec3 normalShading;
};
struct SampleResult
{
	bool outside;
	vec3 direction;
	vec3 throughputDiffuse;
	vec3 throughputConcentrated;
	float pdfOmega;
	vec3 debug;
};

MaterialEvalResult MaterialEvalResultConstruct(vec3 d, vec3 s, vec3 n)
{
	MaterialEvalResult result;
	result.fDiffuse = d;
	result.fConcentrated = s;
	result.normalShading = n;
	return result;
}

//enum class ShaderEvalFlag
//{
//  NONE = 0,
//  DIFFUSE = 1,
//  CONCENTRATED = 2,
//  ALL = DIFFUSE | CONCENTRATED
//};

struct PrincipledBRDFProbabilityResult
{
	bool noStrategy;
	float pDiffuseStrategy;
	float pSpecularStrategy;
	float pRefractiveStrategy;
	bool refractionPossible;
	float FDaccurate;
	float cosT;
};


//////// Sample.cpp

vec2 sampleDiskUniformly(HASTY_INOUT(RNG) rng, HASTY_OUT(float) pDensity)
{
	float alpha = uniform01f(rng) * float(2.0 * Pi);
	float r = sqrt(uniform01f(rng));
	pDensity = float(InvPi);
	return vec2(r * cos(alpha), r * sin(alpha));
}
vec2 sampleCircularNGonUniformly(HASTY_INOUT(RNG) rng, int numBlades, float bladeRotation, HASTY_OUT(float) pDensity)
{
	//assert(bladeRotation >= float(-Pi));
	//assert(numBlades >= 3);

	// do a half plane test with direction of anglePerSector/2
	float anglePerSector = float(2.0 * Pi / numBlades);
	vec2 normal = vec2(cos(anglePerSector * 0.5f), sin(anglePerSector * 0.5f));
	float d = -normal[0];	// offset such that (1,0) is on the border of the half plane

	vec2 samplePosition;
	bool outside;
	do
	{
		samplePosition = sampleDiskUniformly(rng, pDensity);
		float r = norm(samplePosition);
		float angle = atan(samplePosition[1], samplePosition[0]);
		angle -= bladeRotation;
		angle += float(2.0 * Pi) * (1.0f + 1e-6); // make sure angle is bigger than zero
		// now normalize wrt to angular sector:
		angle = mod(angle, anglePerSector);
		vec2 normalizedPosition = vec2(r * cos(angle), r * sin(angle));
		outside = (dot(normal, normalizedPosition) + d) > 0.0f;
	} while(outside);

	float areaSector = 0.5 * sin(anglePerSector); // Area = 0.5 * radius * radius * sin(anglePerSector)
	float areaNGon = numBlades * areaSector;
	pDensity = 1.0 / areaNGon;

	return samplePosition;
}

vec3 sampleHemisphereCosImportance(inout RNG rng, vec3 normal, out float pDensity)
{
	vec3 dir;
	float costheta;
	do
	{
		float xi1 = uniform01f(rng);
		float xi2 = uniform01f(rng);

		float phi = 2.0 * Pi * xi2;
		costheta = sqrt(xi1);
		float sintheta = sqrt(1.0 - xi1); // sqrt(1.0f - costheta * costheta);
		float cosphi = cos(phi);
		float sinphi = sin(phi); // you cannot use sqrt(1 - cosphi*cosphi) here you are gonna loose the sign
		vec3 rv = vec3(sintheta * cosphi, sintheta * sinphi, costheta);

		dir = applyRotation( RotationBetweenTwoVectorsConstruct(vec3(0.0, 0.0, 1.0), normal), rv);
		dir = normalize(dir);
		costheta = dot(dir, normal);
	} while (costheta <= 0.0f); // stay clear from numerical mistakes

	pDensity = InvPi * costheta;
	return dir;
}
float evaluateHemisphereCosImportancePDF(vec3 normal, vec3 direction)
{
	float cosTheta = dot(normal, direction);
	if (cosTheta < 0.0f) return 0.0f;
	return InvPi * cosTheta;
}


//////// BRDF.cpp

#define HASTY_POWCI(v, constantIntegerExponent) pow(v, constantIntegerExponent);

bool computeRefractionDirection(vec3 wi, vec3 normal, float indexOfRefraction_i, float indexOfRefraction_t, HASTY_OUT(vec3) wt)
{
	// t stands for transmittance
	//https://www.pbr-book.org/3ed-2018/Reflection_Models/Specular_Reflection_and_Transmission#sec:specular-transmit
	float relIOR = indexOfRefraction_i / indexOfRefraction_t;
	float cos_i = dot(wi, normal);
	//assert(cos_i >= 0.0f);
	//float side = cos_i >= 0.0f ? 1.0f : -1.0f;
	float sin_iSq = max(0.f, 1.f - cos_i * cos_i);
	float sin_tSq = (relIOR * relIOR) * sin_iSq;
	if(sin_tSq >= 1.0f)
	{
		// in this case we get total internal reflection and we can't compute cos_t (going complex)
		return false;
	}
	float cos_t = sqrt(1.0f - sin_tSq);
	wt = (-relIOR) * wi + (relIOR * cos_i - cos_t) * normal;
	wt = normalize(wt);
	return true;
}
bool computeRefractionCosT(float cos_i, float indexOfRefraction_i, float indexOfRefraction_t, HASTY_OUT(float) cos_t)
{
	//assert(cos_i >= 0.0f);

	// t stands for transmittance
	//https://www.pbr-book.org/3ed-2018/Reflection_Models/Specular_Reflection_and_Transmission#sec:specular-transmit
	float relIOR = indexOfRefraction_i / indexOfRefraction_t;

	//float side = cos_i >= 0.0f ? 1.0f : -1.0f;
	float sin_iSq = max(0.f, 1.f - cos_i * cos_i);
	float sin_tSq = (relIOR * relIOR) * sin_iSq;
	if(sin_tSq >= 1.0f)
	{
		// in this case we get total internal reflection and we can't compute cos_t (going complex)
		return false;
	}
	cos_t = sqrt(1.0f - sin_tSq);
	return true;
}

// normal points in the same direction as wi
vec3 computeRefractionDirectionFromAngles(vec3 wi, vec3 normal, float IORi_over_IORt, float cos_i, float cos_t)
{
	//assert(dot(wi, normal) >= 0.0f);
	//assert(cos_i >= 0.0f);
	//assert(cos_t >= 0.0f);

	vec3 wt = (-IORi_over_IORt) * wi + (IORi_over_IORt * cos_i - cos_t) * normal;
	wt = normalize(wt);
	return wt;
}

//https://psgraphics.blogspot.com/2016/12/bug-in-my-schlick-code.html?m=0
float fresnelSchlick(float cos_i, float indexOfRefraction_i, float indexOfRefraction_t)
{
	//https://en.wikipedia.org/wiki/Schlick%27s_approximation
	float R0 = square((indexOfRefraction_i - indexOfRefraction_t) / (indexOfRefraction_i + indexOfRefraction_t));
	float cosT = cos_i;
	return R0 + (1.0f - R0) * HASTY_POWCI(1.0f - cosT, 5);
}

// https://www.pbr-book.org/3ed-2018/Reflection_Models/Specular_Reflection_and_Transmission
// https://web.cse.ohio-state.edu/~parent.1/classes/782/Lectures/05_Reflectance.pdf
float fresnelDielectric(float cos_i, float cos_t, float indexOfRefraction_i, float indexOfRefraction_t)
{
	//assert(cos_i >= 0.0f);
	//assert(cos_t >= 0.0f);
	float rp = (indexOfRefraction_t * cos_i - indexOfRefraction_i * cos_t) / (indexOfRefraction_t * cos_i + indexOfRefraction_i * cos_t);
	float ro = (indexOfRefraction_i * cos_i - indexOfRefraction_t * cos_t) / (indexOfRefraction_i * cos_i + indexOfRefraction_t * cos_t);
	return 0.5f * (rp * rp + ro * ro);
}

// https://agraphicsguy.wordpress.com/2015/11/01/sampling-microfacet-brdf/
// https://schuttejoe.github.io/post/ggximportancesamplingpart1/
vec3 sampleDGGX(HASTY_INOUT(RNG) rng, vec3 normal, float alpha, vec3 dir1, HASTY_OUT(float) pDensity)
{
	if(dot(dir1, normal) < 0.0f)
	{
		//cout << " warning sampleDGGX from the inside" << '\n'
		pDensity = 1.0f;
		return -normal;
	}
	// theta_h ~ alpha*alpha * cos(theta_h) sin(theta_h) / (float(Pi) * (q * q)), q = (cos(theta_h) ^2 ) * (alpha * alpha - 1.0f) + 1.0f,	 q(0) = a^2, q(\pi/2) = 1
	// F(\theta_h) = \int_0^{\theta_h} 1/C alpha*alpha * cos(\theta_h') / (float(Pi) * (q * q)) d\theta_h' =	[ 1/(Pi C) a^2 / ( 2	(a^2 - 1) q(\theta') )	]_0^\theta_h = 1/(Pi C) a^2 / ( 2	(a^2 - 1) q(\theta_h) ) - 1/(Pi C) a^2 / ( 2	(a^2 - 1) q(0) )
	//						 = 1/(Pi C) a^2 / ( 2	(a^2 - 1) q(\theta_h) ) - 1/(Pi C	2	(a^2 - 1)	) = 1 / (Pi C 2	q(\theta_h) )	
	// F(\pi/2) = 1 = 1 / (Pi C 2) => C =	1 / (pi 2	) 
	// F(\theta_h) = 1 / q(\theta_h) = u = 1 / ((nh * nh) * (alpha * alpha - 1.0f) + 1.0f) , 1 = (nh * nh) * (alpha * alpha - 1.0f) u + u
	//						(1 - u)/(u (alpha^2 - 1) ) = cos(\theta_h)^2
	vec3 h;
	do
	{
		float xi1 = uniform01f(rng);
		float xi2 = uniform01f(rng);

		float phi = 2.0f * float(Pi) * xi2;
		float costheta = sqrt((1.0f - xi1) / (xi1 * (alpha * alpha - 1.0f) + 1.0f)); // using double here on purpose due to numerical problems
		float sintheta = sqrt(1.0f - costheta * costheta);
		float cosphi = cos(phi);
		float sinphi = sin(phi); // you cannot use sqrt(1 - cosphi*cosphi) here you are gonna loose the sign
		vec3 rv = vec3(sintheta * cosphi, sintheta * sinphi, costheta);

		RotationBetweenTwoVectors rotation = RotationBetweenTwoVectorsConstruct(vec3(0.0f, 0.0f, 1.0f), normal);
		h = applyRotation(rotation, rv);
		h = normalize(h);
	} while(dot(h, normal) <= 0.0f);

	// p(dir2) = p( h	| dir1) / abs(det(jac_h(transformation)))
	// dir2 =	2 * dot(h, dir1) * h - dir1
	//	we can just use http://www.matrixcalculus.org/ for the jacobian, sth like: 2 *h * (h'* y) - y, giving	2 h y' + 2 h' y * Identity, determinant is 4 h' y, i guess
	vec3 dir2 = reflectAcross(dir1, h);
	dir2 = normalize(dir2);

	float nh = dot(normal, h);
	float q = (nh * nh) * (alpha * alpha - 1.0f) + 1.0f;
	float pDensityH = alpha * alpha * nh / (float(Pi) * (q * q));
	pDensity = pDensityH / abs(4.0f * dot(dir1, h));
	return dir2;
}
float sampleDGGXDensity(vec3 normal, float alpha, vec3 dir1, vec3 dir2)
{
	vec3 h = normalize(dir1 + dir2); // this is not the "correct" h, the sign may be wrong wrt sampleDGGX, which is why we just use abs on the next line
	float nh = abs(dot(normal, h));
	float q = (nh * nh) * (alpha * alpha - 1.0f) + 1.0f;
	float pDensityH = alpha * alpha * nh / (float(Pi) * (q * q));
	return pDensityH / (1e-7f + abs(4.0f * dot(dir1, h)));
}
float DGGX(float nh, float alpha)
{
	float q = (nh * nh) * (alpha * alpha - 1.0f) + 1.0f;
	float D = alpha * alpha / (1e-7f + float(Pi) * (q * q));
	return D;
}
float SmithIsotropicGGXShadowing(float alpha, float vsq, float vn)
{
	float lambda = (sqrt(1.0f + alpha * alpha * (vsq / (vn * vn) - 1.0f)) - 1.0f) * 0.5f;
	return 1.0f / (1.0f + lambda);
}

float DGGX(float nh, float th, float bh, float alpha_t, float alpha_b)
{
	float D = float(InvPi) / (alpha_t * alpha_b * square(square(th / alpha_t) + square(bh / alpha_b) + square(nh)));
	return D;
}
// "glass ground unknown"
float smithGGX(float nv, float tv, float bv, float alpha_t, float alpha_b)
{
	float lambda = 0.5f * (sqrt(1.0f + (square(alpha_t * tv) + square(alpha_b * bv)) / square(nv)) - 1.0f);
	return 1.0f / (1.0f + lambda);
}
// see "Sampling the GGX Distribution of Visible Normals" Eric Heitz for an explanation
// and https://simonstechblog.blogspot.com/2020/01/note-on-sampling-ggx-distribution-of.html
// and https://schuttejoe.github.io/post/ggximportancesamplingpart2/
vec3 sampleGGXVNDF(vec3 wOut, float alphaX, float alphaY, float xi1, float xi2)
{
	vec3 Vh = normalize(vec3(alphaX * wOut[0], alphaY * wOut[1], wOut[2]));

	// compute frame
	vec3 X = vec3(1.0f, 0.0f, 0.0f);
	vec3 Z = vec3(0.f, 0.f, 1.0f);
	vec3 T1 = cross(Vh, Z);
	if(normSq(T1) < 1e-12f) T1 = X;
	else T1 = normalize(T1);
	vec3 T2 = cross(T1, Vh);

	float r = sqrt(xi1);
	float a = 1.0f / (1.0f + Vh[2]);
	float phi = float(Pi) * ((xi2 < a) ? (xi2 / a) : (1.0f + (xi2 - a) / (1.0f - a)));
	float t1 = r * cos(phi);
	float t2 = r * sin(phi) * (xi2 < a ? 1.0f : Vh[2]);
	float t3 = sqrt(max(0.0f, 1.0f - t1 * t1 - t2 * t2));
	vec3 Nh = t1 * T1 + t2 * T2 + t3 * Vh;
	vec3 Ne = normalize(vec3(alphaX * Nh[0], alphaY * Nh[1], max(0.0f, Nh[2])));

	return Ne;
}
vec3 sampleGGXVNDFGlobal(HASTY_INOUT(RNG) rng, vec3 normal, float alpha_t, float alpha_b, vec3 tangent, vec3 bitangent, vec3 dir1, HASTY_OUT(float) pDensity)
{
	if(dot(dir1, normal) <= 0.0f)
	{
		//cout << " warning sampleGGXVNDFGlobal from the inside" << '\n'
		pDensity = 0.0f;
		return -normal;
	}

	vec3 NeGlobal;
	do
	{
		vec3 Ve = vec3(dot(tangent, dir1), dot(bitangent, dir1), dot(normal, dir1));
		vec3 Ne = sampleGGXVNDF(Ve, alpha_t, alpha_b, uniform01f(rng), uniform01f(rng));

		NeGlobal = tangent * Ne[0] + bitangent * Ne[1] + normal * Ne[2];
		NeGlobal = normalize(NeGlobal);
	} while(dot(NeGlobal, dir1) <= 0.0f);

	vec3 dir2 = reflectAcross(dir1, NeGlobal);
	dir2 = normalize(dir2);
	// V = dir1, N = H
	float G1 = smithGGX(dot(normal, dir1), dot(tangent, dir1), dot(bitangent, dir1), alpha_t, alpha_b);
	float D_ggx = DGGX(dot(normal, NeGlobal), dot(tangent, NeGlobal), dot(bitangent, NeGlobal), alpha_t, alpha_b);
	float pDensityH = G1 * dot(dir1, NeGlobal) * D_ggx / dot(dir1, normal);
	pDensity = pDensityH / (1e-7f + 4.0f * abs(dot(dir1, NeGlobal)));
	return dir2;
}
float sampleGGXVNDFGlobalDensity(vec3 normal, float alpha_t, float alpha_b, vec3 tangent, vec3 bitangent, vec3 dir1, vec3 dir2)
{
	if(dot(dir1, normal) <= 0.0f)
	{
		//cout << " warning sampleGGXVNDFGlobalDensity from the inside" << '\n'
		return 0.0f;
	}
	vec3 NeGlobal = normalize(dir1 + dir2);
	float G1 = smithGGX(dot(normal, dir1), dot(tangent, dir1), dot(bitangent, dir1), alpha_t, alpha_b);
	float D_ggx = DGGX(dot(normal, NeGlobal), dot(tangent, NeGlobal), dot(bitangent, NeGlobal), alpha_t, alpha_b);
	float pDensityH = G1 * max(0.0f, dot(dir1, NeGlobal)) * D_ggx / dot(dir1, normal);
	return pDensityH / (1e-7f + 4.0f * abs(dot(dir1, NeGlobal)));
}

float signSide(float dotNW)
{
	return dotNW < 0.0f ? -1.0f : 1.0f;
}

bool sideOutside(float dotNW)
{
	return dotNW >= 0.0f;
}

float computeNormalScale(vec3 wi, vec3 normalShading, vec3 normalGeometric)
{
	return abs(dot(wi, normalShading)) / (1e-7f + abs(dot(wi, normalGeometric)));
}


// Goal : mix(mix(DielectricBRDF, GlassBRDF,	transmission), metallicBRDF, metallic)
//	 where DielectricBRDF, GlassBRDF and metallicBRDF is a fully working BRDF, and the grouping like this is cause glass is a dielectric...
// but this can be simplified because we use a simpler model where the specular lobe of the metallic, the dielectric and the "glass"
// mix(mix(DielectricBRDFDiffuse, GlassBRDFDiffuse,	transmission), metallicBRDFDiffuse, metallic)
//	= mix(mix(DielectricBRDFDiffuse, 0,	transmission), 0, metallic)
//	= DielectricBRDFDiffuse * (1.0 - transmission) * (1.0 - metallic)
//	= Lambertian * (1.0f - 0.5f * specularHit) * (1.0 - transmissionHit) * (1.0 - metallicHit)

float PrincipledBRDFcomputeAlpha(float roughness)
{
	//we have alpha min to not have dirac distribution as special case
	float alpha = roughness * roughness;
	if(alpha < 1e-2f && alpha != 0.0f) // we handle alpha == 0.0f specifically
	{
		////cout << " warning: roughness very small, clamping due to instabilities " << endl
		alpha = 1e-2f;
	}
	return alpha;
}
PrincipledBRDFProbabilityResult PrincipledBRDFcomputeProbability(float metallicHit, float specularHit, float transmissionHit, float cos_o, float indexOfRefraction_o, float indexOfRefraction_refr_o)
{
	//assert(cos_o >= 0.0f);
	PrincipledBRDFProbabilityResult result;
	result.refractionPossible = computeRefractionCosT(cos_o, indexOfRefraction_o, indexOfRefraction_refr_o, result.cosT);
	if(result.refractionPossible)
	{
		result.FDaccurate = fresnelDielectric(cos_o, result.cosT, indexOfRefraction_o, indexOfRefraction_refr_o); // goes from 0 to 1 for cos_i going from 0 to 90 degrees, at higher degrees we get more reflection
	}
	else
	{
		result.FDaccurate = 1.0f;
	}

	float mDiffuseStrategy = (1.0f - transmissionHit) * (1.0f - metallicHit) * (1.0f - 0.5f * specularHit); // we want this to be zero when metallic and one when specular = 0
	float sTransmission = result.FDaccurate;
	float sMetallic = 1.0f;
	float mSpecularStrategy = mix(mix(0.5f * specularHit, sTransmission, transmissionHit), sMetallic, metallicHit);
	float mRefractiveStrategy = (1.0 - result.FDaccurate) * transmissionHit * (1.0 - metallicHit);

	//if(!has(evalFlag, ShaderEvalFlagDIFFUSE)) mDiffuseStrategy = 0.0f;
	//if(!has(evalFlag, ShaderEvalFlagCONCENTRATED))
	//{
	//	mSpecularStrategy = 0.0f;
	//	mRefractiveStrategy = 0.0f;
	//}

	float mSum = mDiffuseStrategy + mSpecularStrategy + mRefractiveStrategy;
	result.noStrategy = mSum == 0.0f;
	if(result.noStrategy)
	{
		result.pDiffuseStrategy = 0.0f;
		result.pSpecularStrategy = 0.0f;
		result.pRefractiveStrategy = 0.0f;
	}
	else
	{
		result.pDiffuseStrategy = mDiffuseStrategy / mSum;
		result.pSpecularStrategy = mSpecularStrategy / mSum;
		result.pRefractiveStrategy = mRefractiveStrategy / mSum;
	}

	return result;
}
void PrincipledBRDFcomputeAnisotropyParameters(SurfaceInteraction interaction, vec3 normalShading, float alpha, float anisotropyHit, HASTY_OUT(float) alpha_t, HASTY_OUT(float) alpha_b, HASTY_OUT(vec3) tangent, HASTY_OUT(vec3) bitangent)
{
	float aspect = sqrt(1.0f - 0.9f * anisotropyHit);
	alpha_t = alpha / aspect;
	alpha_b = alpha * aspect;
	RotationBetweenTwoVectors rotation = RotationBetweenTwoVectorsConstruct(interaction.normalGeometric, normalShading);
	tangent = applyRotation(rotation, interaction.tangent);
	bitangent = applyRotation(rotation, interaction.bitangent);
}

// this function assumes that dot(Ns, wo) >= 0
vec3 PrincipledBRDFevaluateDiffuse(float dotNsWi, vec3 albedoHit, float normalScale, float metallicHit, float specularHit, float transmissionHit)
{
	if(dotNsWi < 0.0f)
	{
		return vec3(0.0);
	}
	return albedoHit * (float(InvPi) * normalScale * (1.0f - 0.5f * specularHit) * (1.0 - transmissionHit) * (1.0 - metallicHit));
}
// this function assumes that dot(Ns, wo) >= 0
vec3 PrincipledBRDFevaluateConcentratedWithoutTransmission(
	float dotNsWi,
	vec3 albedoHit, float metallicHit, float specularHit,
	float roughnessHit, float anisotropyHit, float transmissionHit,
	vec3 wo, vec3 wi,
	float alpha,
	float alpha_t, float alpha_b,
	vec3 tangent, vec3 bitangent,
	vec3 normalShading,
	float normalScale,
	bool forceHitSpecular,
	vec3 FDaccurate)
{
	if(dotNsWi < 0.0f) return vec3(0.0);

	vec3 h = normalize(wo + wi);
	float lh = abs(dot(wi, h));

	//Pseudo fresnel:
	// https://www.youtube.com/watch?v=kEcDbl7eS0w basically F0 is directly the color one desires in the middle, and it's actually more principled to use F0 + SChlick than using the full fresnel equations because we don't do proper spectral rendering
	float cosNih5 = HASTY_POWCI(1.0f - lh, 5);
	// FH * D * G / (4 * nv * nl) with:
	//vec3 F0 = mix(vec3(1.0), albedoHit, metallicHit); // and we also have a specular part for non metalics, in that case it's kinda white, wheras for a metallic object the light gets "colored"
	//vec3 FH = F0 + (vec3(1.0) - F0) * cosNih5; // here if we are at a grazing angle, we	remove some F0, and add some "achromatic" reflectance (vec3ones)
	//vec3 FH = F0 + vec3(1.0) * cosNih5 - F0 * cosNih5;
	//vec3 FH = mix(vec3(1.0), albedoHit, metallicHit) * (1.0f - cosNih5) + vec3(1.0) * cosNih5;
	//vec3 FH = mix(vec3(1.0) * (1.0f - cosNih5), albedoHit * (1.0f - cosi5), metallicHit) + vec3(1.0) * cosNih5;
	//vec3 FH = mix(vec3(1.0) * (1.0f - cosNih5) + vec3(1.0) * cosNih5, albedoHit * (1.0f - cosNih5) + vec3(1.0) * cosi5, metallicHit);
	//vec3 FH = mix(vec3(1.0), albedoHit * (1.0f - cosNih5) + vec3(1.0) * cosNih5, metallicHit);

	float nh = dot(normalShading, h);

	float nv = abs(dot(normalShading, wo));
	float nl = abs(dot(normalShading, wi));
	float Go = smithGGX(nv, dot(tangent, wo), dot(bitangent, wo), alpha_t, alpha_b);
	float Gi = smithGGX(nl, dot(tangent, wi), dot(bitangent, wi), alpha_t, alpha_b);
	float G = Go * Gi;

	float D_ggx;

	if(alpha == 0.0f)
	{
		// D_GGX explodes for alpha= 0 and nh = 1
		// we can find this by using importance sample formula and then let alpha go to zero?, G is always 1 in that case
		// => \int F D G/ (4 nv nl) dl ~= 1/N \sum_i	F D Gi Go/ (4 nv nl_i	p(l_i) )
		//					 ~= 1/N \sum_i	F / nv ~=	 F / nv for alpha = 0
		D_ggx = forceHitSpecular ? 4.0f * nl : 0.0f; // or 4.0f * nv? nv and nl should be the same for a fully reflective hit
	}
	else
	{
		D_ggx = DGGX(nh, dot(tangent, h), dot(bitangent, h), alpha_t, alpha_b);
	}

	float specularFromDielectric = 0.5f * specularHit;
	vec3 specFromTransmission = vec3(0.0);
	vec3 specularMetallic = albedoHit * (1.0f - cosNih5) + vec3(1.0) * cosNih5;

	vec3 resultTransmission = vec3(0.0);
	if(transmissionHit > 0.0f)
	{
		//if(alpha != 0.0f) throw runtime_error("not implemented");
		specFromTransmission = forceHitSpecular ? FDaccurate : vec3(0.0);
	}
	vec3 resultSpecular = mix(mix(vec3(specularFromDielectric), specFromTransmission, transmissionHit), specularMetallic, metallicHit) * (D_ggx * G * normalScale / abs(1e-7f + 4.0f * nv * nl));
	vec3 result = resultSpecular;
	return result;
}

//wavelength \in [-1, 0, 1, 2] where -1 means the same index of refraction for all wavelengths
SampleResult PrincipledBRDFsample(
	HASTY_INOUT(RNG) rng, SurfaceInteraction interaction, vec3 wo, vec3 normalShading,
	vec3 albedoHit,
	float metallicHit, float specularHit, float roughnessHit, float anisotropyHit, float transmissionHit,
	int wavelength, float indexOfRefractionOutside, float indexOfRefractionMat)
{
	SampleResult result;

	//assert(evalFlag != ShaderEvalFlagNONE); // no distribution to sample
	//assert(dot(normalShading, wo) >= 0.0f);

	float dotNgWo = dot(interaction.normalGeometric, wo);
	float dotNsWo = dot(normalShading, wo);

	float alpha = PrincipledBRDFcomputeAlpha(roughnessHit);

	result.outside = sideOutside(dotNgWo);
	float indexOfRefraction_o = result.outside ? indexOfRefractionOutside : indexOfRefractionMat;
	float indexOfRefraction_refr_o = result.outside ? indexOfRefractionMat : indexOfRefractionOutside;

	PrincipledBRDFProbabilityResult probabilityResult = PrincipledBRDFcomputeProbability(metallicHit, specularHit, transmissionHit, dotNsWo, indexOfRefraction_o, indexOfRefraction_refr_o);

	if(probabilityResult.noStrategy)
	{
		result.direction = vec3(1.0f, 0.0f, 0.0f);
		result.throughputDiffuse = vec3(0.0);
		result.throughputConcentrated = vec3(0.0);
		result.pdfOmega = 0.0f;
		return result;
	}

	// we just put the same Fresnel term in for all wavelengths and then mask the output:
	// we may need to change a lot fo rough glass material...
	vec3 FDaccurateVector = vec3(probabilityResult.FDaccurate);
	vec3 wavelengthMask = vec3(1.0);
	if(wavelength != -1)
	{
		wavelengthMask = vec3(0.0);
		wavelengthMask[wavelength] = 1.0f;
	}

	float alpha_t, alpha_b;
	vec3 tangent, bitangent;
	PrincipledBRDFcomputeAnisotropyParameters(interaction, normalShading, alpha, anisotropyHit, alpha_t, alpha_b, tangent, bitangent);

	// pSpecStr = proability to sample using Specular Strategy
	// p_diff = probability density of diffuse sampling scheme
	// p_spec = probability density of specular sampling scheme
	//F = f L cos(omega) / p(omega)	, omega ~ uniform
	//E[F] = \int f L cos(omega) / p(omega) * p(omega) domega = \int f L cos(omega) domega
	//F' = {
	//			f L cos(omega) / (pSpecStr p_spec(omega) + (1 - pSpecStr) p_diff(omega)) , omega ~ p(spec)		 xi < pSpecStr
	//			f L cos(omega) / (pSpecStr p_spec(omega) + (1 - pSpecStr) p_diff(omega)), omega ~ p(diffuse) xi >= pSpecStr
	//		 }
	//E[F'] = pSpecStr \int f L cos(omega) / (pSpecStr p_spec(omega) + (1 - pSpecStr) p_diff(omega))	p_spec(omega) domega + (1 - pSpecStr) \int f L cos(omega) / (pSpecStr p_spec(omega) + (1 - pSpecStr) p_diff(omega)) p_diff(omega) domega
	//			 = \int f L cos(omega)	(pSpecStr	p_spec(omega) + (1 - pSpecStr)p_diff(omega)) / (pSpecStr p_spec(omega) + (1 - pSpecStr) p_diff(omega))) domega
	//			 = \int f L cos(omega) domega = E[F]

	MaterialEvalResult evalResult = MaterialEvalResult(vec3(0.0), vec3(0.0), normalShading);

	// using defines here instead of enums to support glsl
#define PBRDF_STRATEGY_DIFFUSE 1u
#define PBRDF_STRATEGY_SPECULAR 2u
#define PBRDF_STRATEGY_REFRACTIVE 3u

	float xi = uniform01f(rng); // xi \in [0, 1)
	uint strategy = xi < probabilityResult.pRefractiveStrategy ? PBRDF_STRATEGY_REFRACTIVE : (xi < (probabilityResult.pRefractiveStrategy + probabilityResult.pSpecularStrategy) ? PBRDF_STRATEGY_SPECULAR : PBRDF_STRATEGY_DIFFUSE);
	if(strategy == PBRDF_STRATEGY_SPECULAR)
	{

		if(alpha == 0.0f) // delta distribution; need to keep wierd fake measure
		{
			//F' = {
			//			(f_specular L cos(omegaSpec)) / pSpecStr, omega = omegaSpec		 xi < pSpecStr
			//			f_diffuse L cos(omega) / ((1 - pSpecStr) p_diff), omega ~ p_diff xi >= pSpecStr
			//		 }
			//E[F'] = pSpecStr f_specular(omega) L(omega) cos(omegaSpec) / pSpecStr + (1 - pSpecStr) \int f_diffuse L cos(omega) / ((1 - pSpecStr) pDiffuse) pDiffuse(omega) domega
			//			 = L f_specular(omega_specular) cos(omega_specular) + \int L cos(omega) f_diffuse(omega) domega
			//			 = \int	L cos(omega) f_specular dirac_specular(omega) domega + \int L cos(omega) f_diffuse domega
			//			 = \int	L cos(omega) (f_specular dirac_specular(omega)	+	f_diffuse) domega
			result.direction = reflectAcross(wo, normalShading);
			result.pdfOmega = 1e12f; // this is the probability for MIS , we could also tell it directly that it's a dirac delta but this should work to working precision
			vec3 wi = result.direction;
			float dotNsWi = dot(normalShading, wi);
			float normalScale = computeNormalScale(wi, normalShading, interaction.normalGeometric);
			evalResult.fDiffuse = vec3(0.0);
			evalResult.fConcentrated = 1e12f / probabilityResult.pSpecularStrategy * PrincipledBRDFevaluateConcentratedWithoutTransmission(
				dotNsWi,
				albedoHit, metallicHit, specularHit,
				roughnessHit, anisotropyHit, transmissionHit,
				wo, result.direction,
				alpha,
				alpha_t, alpha_b,
				tangent, bitangent,
				normalShading, normalScale, true, FDaccurateVector);
		}
		else
		{
			int k = 3;
			RNG backup = rng;
			rng = backup;
			float pdfSpec;
			result.direction = sampleGGXVNDFGlobal(rng, normalShading, alpha_t, alpha_b, tangent, bitangent, wo, pdfSpec);
			float pdfDiffuse = evaluateHemisphereCosImportancePDF(normalShading, result.direction);

			result.pdfOmega = probabilityResult.pSpecularStrategy * pdfSpec + probabilityResult.pDiffuseStrategy * pdfDiffuse;
			vec3 wi = result.direction;
			float dotNsWi = dot(normalShading, wi);
			float normalScale = computeNormalScale(wi, normalShading, interaction.normalGeometric);
			evalResult.fDiffuse = PrincipledBRDFevaluateDiffuse(dotNsWi, albedoHit, normalScale, metallicHit, specularHit, transmissionHit);
			evalResult.fConcentrated = PrincipledBRDFevaluateConcentratedWithoutTransmission(
				dotNsWi,
				albedoHit, metallicHit, specularHit,
				roughnessHit, anisotropyHit, transmissionHit,
				wo, result.direction,
				alpha,
				alpha_t, alpha_b,
				tangent, bitangent,
				normalShading, normalScale, false, FDaccurateVector);
		}
	}
	else if(strategy == PBRDF_STRATEGY_DIFFUSE)
	{
		float pdfDiffuse;
		result.direction = sampleHemisphereCosImportance(rng, normalShading, pdfDiffuse);
		vec3 wi = result.direction;
		float dotNsWi = dot(normalShading, wi);
		float normalScale = computeNormalScale(wi, normalShading, interaction.normalGeometric);

		if(alpha == 0.0f) // delta distribution; need to keep wierd fake measure
		{
			result.pdfOmega = probabilityResult.pDiffuseStrategy * pdfDiffuse;
			evalResult.fDiffuse = PrincipledBRDFevaluateDiffuse(dotNsWi, albedoHit, normalScale, metallicHit, specularHit, transmissionHit);
			evalResult.fConcentrated = vec3(0.0);
		}
		else
		{
			float pdfSpec = sampleGGXVNDFGlobalDensity(normalShading, alpha_t, alpha_b, tangent, bitangent, wo, result.direction);
			result.pdfOmega = probabilityResult.pSpecularStrategy * pdfSpec + (1.0f - probabilityResult.pSpecularStrategy) * pdfDiffuse;
			evalResult.fDiffuse = PrincipledBRDFevaluateDiffuse(dotNsWi, albedoHit, normalScale, metallicHit, specularHit, transmissionHit);
			evalResult.fConcentrated = PrincipledBRDFevaluateConcentratedWithoutTransmission(
				dotNsWi,
				albedoHit, metallicHit, specularHit,
				roughnessHit, anisotropyHit, transmissionHit,
				wo, result.direction,
				alpha,
				alpha_t, alpha_b,
				tangent, bitangent,
				normalShading, normalScale, false, FDaccurateVector);
		}
	}
	else
	{
		// refraction: switch outside
		result.outside = !result.outside;
		result.pdfOmega = 1e12f;
		evalResult.fDiffuse = vec3(0.0);
		if(!probabilityResult.refractionPossible)
		{
			evalResult.fConcentrated = vec3(0.0);
			result.direction = vec3(1.0f, 0.0f, 0.0f);
		}
		else
		{
			float iorO_over_iorRo = indexOfRefraction_o / indexOfRefraction_refr_o;
			vec3 wi = computeRefractionDirectionFromAngles(wo, normalShading, iorO_over_iorRo, dotNsWo, probabilityResult.cosT);
			result.direction = wi;
			float scale = square(iorO_over_iorRo); // See "Non-symmetric Scattering in Light Transport Algorithms" the eq. after eq. 10
			float fc = result.pdfOmega / probabilityResult.pRefractiveStrategy * scale * (1.0f - probabilityResult.FDaccurate) / abs(dot(result.direction, interaction.normalGeometric));
			evalResult.fConcentrated = fc * wavelengthMask;
		}
	}

	float m = abs(dot(result.direction, interaction.normalGeometric)) / result.pdfOmega;
	result.throughputDiffuse = evalResult.fDiffuse * m;
	result.throughputConcentrated = evalResult.fConcentrated * m;

	//assertUnitLength(result.direction);
	//assertFinite(result.throughputDiffuse);
	//assertFinite(result.throughputConcentrated);
	//assertFinite(result.pdfOmega);
	return result;
}

vec3 PrincipledBRDFgetShadingNormal(SurfaceInteraction interaction, vec3 wo, float dotNgWo)
{
	float sideNgWo = signSide(dotNgWo);
	vec3 normalShading;
	// first we make sure we have a normal that points in the same direction wrt wo
	normalShading = interaction.normalShadingDefault;
	float sideNsWo = signSide(dot(normalShading, wo));
	if(sideNgWo != sideNsWo)
	{
		normalShading = interaction.normalGeometric; // this is not consistent but good enough for the hack called normal map
	}
	// here we guarantuee signSide(normalShading, wo) == signSide(interaction.normalGeometric, wo)
	// but now we flip it according to normalGeometric:
	normalShading *= sideNgWo;
	return normalShading;
}


//////// Camera.cpp

void cameraRay(HASTY_INOUT(RNG) rng, vec2 pixelPosition, vec2 frameSize, out vec3 origin, out vec3 direction){
	// we aren't doing	a "physical" lense for now
	 // focal plane is at m_position + m_forward * m_focal distance
	// we move origin of the ray randomly, but on the focal plane these rays have to hit the same point independent of the random offset
	vec2 lam = (2.0f * pixelPosition - frameSize) / frameSize.x;
	direction = camera.forward + camera.right * (camera.fovSlope * lam.x) - camera.up * (camera.fovSlope * lam.y);
	direction = normalize(direction);
	if(camera.apertureSize > 0.0){
		float density;
		vec2 offset = sampleCircularNGonUniformly(rng, camera.numBlades, camera.bladeRotation, density);
		float t = camera.focalDistance * dot(direction, camera.forward);
		vec3 focalPoint = camera.position + t * direction;
		origin = camera.position + camera.apertureSize * offset[0] * camera.up + camera.apertureSize * offset[1] * camera.right;
		// now adapt the direction
		direction = normalize(focalPoint - origin);
	} else {
		origin = camera.position;
	}
}

//////// Scene.cpp

SurfaceInteraction getSurfaceInteraction(rayQueryEXT rayQuery){
	
	SurfaceInteraction interaction;
	
	interaction.primitiveID = rayQueryGetIntersectionPrimitiveIndexEXT(rayQuery, true);
	vec2 barycentrics2 = rayQueryGetIntersectionBarycentricsEXT(rayQuery, true);
	float b0 = 1.0 - barycentrics2[0] - barycentrics2[1];
	vec3 barycentricCoordinates = vec3(b0, barycentrics2);
	
	TriangleData triangle = triangles[interaction.primitiveID];
	
	uint vtxIdx0 = triangle.vertexIndices[0];
	uint vtxIdx1 = triangle.vertexIndices[1];
	uint vtxIdx2 = triangle.vertexIndices[2];

	vec3 v0 = vertices[vtxIdx0];
	vec3 v1 = vertices[vtxIdx1];
	vec3 v2 = vertices[vtxIdx2];
	
	vec2 uv0 = triangle.textureCoordinates[0];
	vec2 uv1 = triangle.textureCoordinates[1];
	vec2 uv2 = triangle.textureCoordinates[2];
	
	interaction.x = barycentricCoordinates[0] * v0 + barycentricCoordinates[1] * v1 + barycentricCoordinates[2] * v2;
	interaction.uv = barycentricCoordinates[0] * uv0 + barycentricCoordinates[1] * uv1 + barycentricCoordinates[2] * uv2;
	interaction.uvInverted = vec2(interaction.uv.x, 1.0 - interaction.uv.y);
	
	vec3 m = cross(v1 - v0, v2 - v0);
	interaction.normalGeometric = normalize(m);
	
	interaction.tangent = anyOrthonormal(interaction.normalGeometric);
	interaction.bitangent = cross(interaction.normalGeometric, interaction.tangent);
	interaction.materialIndex = triangle.materialIndex;
	
	bool smoothNormals = triangle.normalIndices[0] != -1;
	if(smoothNormals){
		vec3 nv0 = normals[triangle.normalIndices[0]];
		vec3 nv1 = normals[triangle.normalIndices[1]];
		vec3 nv2 = normals[triangle.normalIndices[2]];
		interaction.normalShadingDefault = barycentricCoordinates[0] * nv0 + barycentricCoordinates[1] * nv1 + barycentricCoordinates[2] * nv2;
		interaction.normalShadingDefault = normalize(interaction.normalShadingDefault);
	} else {
		interaction.normalShadingDefault = interaction.normalGeometric;
	}

	
	return interaction;
}

vec3 getEmissionRadiance(vec3 wo, vec3 normal, Material material){
	return dot(wo, normal) >= 0.0 ? material.emission * InvPi : vec3(0.0);
}



void main()
{
	ivec2 size = imageSize(colorImage);
	ivec2 loc = ivec2(gl_GlobalInvocationID.xy);
	
	if(loc.x < size[0] && loc.y < size[1])
	{
		uint pixelLinearIndex = size[0] * loc[1] + loc[0];
		
		uint seed0 = randomInputState[3 * pixelLinearIndex + 0];
		uint seed1 = randomInputState[3 * pixelLinearIndex + 1];
		uint seed2 = randomInputState[3 * pixelLinearIndex + 2];
		
		vec3 sumColorSamples = imageLoad(colorImage, loc).xyz;
		vec3 sumNormalSamples = imageLoad(normalImage, loc).xyz;
		vec3 sumAlbedoSamples = imageLoad(albedoImage, loc).xyz;
		
		RNG rng = RNGConstruct(seed0, seed1, seed2);
		
		for(int sampleIdx = 0; sampleIdx < nSamples; sampleIdx++){
		
			vec3 colorSample = vec3(0.0);
			vec3 throughput = vec3(1.0);
			
			const vec2 pixelPosition = vec2(loc) + vec2(uniform01f(rng), uniform01f(rng));
			vec3 rayOrigin, rayDirection;
			cameraRay(rng, pixelPosition, size, rayOrigin, rayDirection);
			LightRay lightRay = LightRayConstruct();
			
			for(int depth = 0; depth < 10; depth++){
				
				rayQueryEXT rayQuery;
				rayQueryInitializeEXT(
					rayQuery,
					tlas,
					gl_RayFlagsOpaqueEXT,
					0xFF,
					rayOrigin,
					1e-5,
					rayDirection,
					10000.0);
				while(rayQueryProceedEXT(rayQuery))
				{
				}
				
				if(rayQueryGetIntersectionTypeEXT(rayQuery, true) == gl_RayQueryCommittedIntersectionTriangleEXT)
				{
					SurfaceInteraction interaction = getSurfaceInteraction(rayQuery);
					
					vec3 wo = -rayDirection;
					throughput *= beersLaw(getTransmittance(lightRay), norm(interaction.x - rayOrigin));
					
					uint materialIdx = interaction.materialIndex;
					int mediumId = int(materialIdx); // this currently works because in practice it only depends on the material and all material ids will have same transmittance
					Material material = materials[materialIdx];
					
					vec3 albedoHit = texture(albedoTextures[materialIdx], interaction.uvInverted).xyz;
					
					if(depth == 0){
						sumNormalSamples += interaction.normalGeometric;
						sumAlbedoSamples += albedoHit;
					}
					
					vec3 emission = getEmissionRadiance(wo, interaction.normalGeometric, material);
					
					colorSample += throughput * emission;
					if(dot(emission,emission) > 0.0) break;
					
					bool beforeOutside = dot(interaction.normalGeometric, wo) > 0.0f; // wrt geometric normal
					
					const float metallicHit = texture(metallicTextures[materialIdx], interaction.uvInverted).x;
					const float roughnessHit = texture(roughnessTextures[materialIdx], interaction.uvInverted).x;
					
					const float specularHit = material.specular;
					const float anisotropyHit = material.anisotropy;
					const float indexOfRefractionOutside = getOutsideIOR(lightRay, beforeOutside, mediumId);
					const float indexOfRefractionMat = material.indexOfRefraction;
					const float transmissionHit = material.transmission;
					int wavelength = -1;
					vec3 normalShading = PrincipledBRDFgetShadingNormal(interaction, wo, dot(interaction.normalGeometric, wo));
					
					SampleResult sampleResult = PrincipledBRDFsample(
						rng, interaction, wo, normalShading,
						albedoHit,
						metallicHit, specularHit, roughnessHit, anisotropyHit, transmissionHit,
						wavelength, indexOfRefractionOutside, indexOfRefractionMat);
					
					vec3 throughputHit = sampleResult.throughputDiffuse + sampleResult.throughputConcentrated;
					
					throughput *= throughputHit;
					
					rayOrigin = interaction.x + (sampleResult.outside ? 1e-4 : -1e-4) * interaction.normalGeometric;
					rayDirection = sampleResult.direction;
					
					bool afterOutside = sampleResult.outside; // wrt geometric normal
					updateMedium(lightRay, beforeOutside, afterOutside, mediumId, albedoHit, indexOfRefractionMat);
				} else {
					throughput *= beersLaw(getTransmittance(lightRay), 1e6f);
					vec3 Le = backgroundColor;
					colorSample += throughput * Le;
					break;
				}
				
				float rouletteP = depth > 2 ? 0.30 : 0.0;
				if(uniform01f(rng) < rouletteP){
					break;
				}
				throughput /= (1.0 - rouletteP);
			}
			
			
			sumColorSamples += colorSample;
		}
		
		randomInputState[3 * pixelLinearIndex + 0] = rng.s1;
		randomInputState[3 * pixelLinearIndex + 1] = rng.s2;
		randomInputState[3 * pixelLinearIndex + 2] = rng.s3;
		
		imageStore(colorImage, loc, vec4(sumColorSamples, 1.0));
		imageStore(normalImage, loc, vec4(sumNormalSamples, 1.0));
		imageStore(albedoImage, loc, vec4(sumAlbedoSamples, 1.0));
	}
}
