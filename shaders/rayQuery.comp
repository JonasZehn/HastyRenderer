#version 460
#extension GL_EXT_ray_query : require
#extension GL_EXT_scalar_block_layout : require
 
layout(local_size_x = 4, local_size_y = 4, local_size_z = 1) in;

layout(binding = 0, set = 0) uniform accelerationStructureEXT tlas;
layout(binding = 1, set = 0, rgba32f) uniform image2D resultImage;

layout(binding = 2, set = 0, scalar) buffer Vertices
{
	vec3 vertices[];
};
layout(binding = 3, set = 0, scalar) buffer Indices
{
	uint indices[];
};
layout(binding = 4, set = 0, scalar) buffer Colors
{
	vec3 colors[];
};

layout(binding = 5, scalar) uniform Camera {
	vec3 position;
	float fovSlope;
    vec3 forward;
    vec3 right;
    vec3 up;
} camera;


vec3 cameraRay(vec2 pixelPosition, vec2 frameSize){
	const vec2 lam = (2.0 * pixelPosition - vec2(frameSize) ) / frameSize.x;
    vec3 rayDirection = camera.forward + camera.right * (camera.fovSlope * lam.x) + camera.up * (-camera.fovSlope * lam.y);
	return rayDirection;
}

struct HaltonSequence1 {
	int b;
	int n;
	int d;
};
HaltonSequence1 HaltonSequence1Init(int b){
	HaltonSequence1 result;
	result.b = b;
	result.n = 0;
	result.d = 1;
	return result;
}
float haltonSequence1Update(inout HaltonSequence1 seq){
    int x = seq.d - seq.n;
    if (x == 1)
    {
      seq.n = 1;
      seq.d *= seq.b;
    }
    else
    {
      int y = seq.d / seq.b;
      while (x <= y)
      {
        y /= seq.b;
      }
      seq.n = (seq.b + 1) * y - x;
    }
    return float(seq.n) / seq.d;
}
struct HaltonSequence2 {
	HaltonSequence1 s1;
	HaltonSequence1 s2;
};
HaltonSequence2 HaltonSequence2Init(){
	HaltonSequence2 result;
	result.s1 = HaltonSequence1Init(2);
	result.s2 = HaltonSequence1Init(3);
	return result;
}
vec2 HaltonSequence2Update(inout HaltonSequence2 seq){
	vec2 result;
	result.x = haltonSequence1Update(seq.s1);
	result.y = haltonSequence1Update(seq.s2);
	return result;
}

void main()
{
	ivec2 loc = ivec2(gl_GlobalInvocationID.xy);
	
	ivec2 size = imageSize(resultImage);
	ivec4 imageExtent = { 0, 0, size[0], size[1] };
	
	vec3 rayOrigin = camera.position;
	
	const int nSamples = 10;
	
	vec3 sumSamples = vec3(0.0);
	HaltonSequence2 pixelPositionSeq = HaltonSequence2Init();
	for(int sampleIdx=0; sampleIdx < nSamples; sampleIdx++){
	
		vec3 result = vec3(0.0);
		
		const vec2 pixelPosition = vec2(loc) + HaltonSequence2Update(pixelPositionSeq);
		vec3 rayDirection = cameraRay(pixelPosition, size);
		
		rayQueryEXT rayQuery;
		rayQueryInitializeEXT(
			rayQuery,
			tlas,
			gl_RayFlagsOpaqueEXT,
			0xFF,
			rayOrigin,
			0.0,
			rayDirection,
			10000.0);
		while(rayQueryProceedEXT(rayQuery))
		{
		}
		
		if(rayQueryGetIntersectionTypeEXT(rayQuery, true) == gl_RayQueryCommittedIntersectionTriangleEXT)
		{
			const int primitiveID = rayQueryGetIntersectionPrimitiveIndexEXT(rayQuery, true);
			
			result = colors[primitiveID];
		}
		
		sumSamples += result;
	}
	
	
	vec4 estimate = vec4(sumSamples /  nSamples, 1.0);
	
	if(loc.x >= imageExtent[0] && loc.y >= imageExtent[1] 
		&& loc.x < imageExtent[2] && loc.y < imageExtent[3])
	{
		imageStore(resultImage, loc, estimate);
	}
}