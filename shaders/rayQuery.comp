#version 460
#extension GL_EXT_ray_query : require
#extension GL_EXT_scalar_block_layout : require
 
layout(local_size_x = 4, local_size_y = 4, local_size_z = 1) in;

layout(binding = 0, set = 0) uniform accelerationStructureEXT tlas;
layout(binding = 1, set = 0, rgba32f) uniform image2D resultImage;

layout(binding = 2, set = 0, scalar) buffer Vertices
{
	vec3 vertices[];
};
layout(binding = 3, set = 0, scalar) buffer Indices
{
	uint indices[];
};
layout(binding = 4, set = 0, scalar) buffer Colors
{
	vec3 colors[];
};

layout(binding = 5, scalar) uniform Camera {
	vec3 position;
	float fovSlope;
    vec3 forward;
    vec3 right;
    vec3 up;
} camera;


vec3 cameraRay(vec2 pixelPosition, vec2 frameSize){
	const vec2 lam = (2.0 * pixelPosition - vec2(frameSize) ) / frameSize.x;
    vec3 rayDirection = camera.forward + camera.right * (camera.fovSlope * lam.x) + camera.up * (-camera.fovSlope * lam.y);
	return rayDirection;
}


void main()
{
	ivec2 loc = ivec2(gl_GlobalInvocationID.xy);
	
	ivec2 size = imageSize(resultImage);
	ivec4 imageExtent = { 0, 0, size[0], size[1] };
	
    const vec2 pixelPosition = vec2(loc) + vec2(0.5);
	vec3 rayOrigin = camera.position;
	vec3 rayDirection = cameraRay(pixelPosition, size);
	
	vec4 result = vec4(0.0);
	
	rayQueryEXT rayQuery;
	rayQueryInitializeEXT(
		rayQuery,
		tlas,
		gl_RayFlagsOpaqueEXT,
		0xFF,
		rayOrigin,
		0.0,
		rayDirection,
		10000.0);
	while(rayQueryProceedEXT(rayQuery))
	{
	}
	
	if(rayQueryGetIntersectionTypeEXT(rayQuery, true) == gl_RayQueryCommittedIntersectionTriangleEXT)
	{
		const int primitiveID = rayQueryGetIntersectionPrimitiveIndexEXT(rayQuery, true);
		
		result.xyz = colors[primitiveID];
	}
	result.a = 1.0;
	
	if(loc.x >= imageExtent[0] && loc.y >= imageExtent[1] 
		&& loc.x < imageExtent[2] && loc.y < imageExtent[3])
	{
		imageStore(resultImage, loc, result);
	}
}