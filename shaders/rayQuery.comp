#version 460
#extension GL_EXT_ray_query : require
#extension GL_EXT_scalar_block_layout : require
 
layout(local_size_x = 4, local_size_y = 4, local_size_z = 1) in;

layout(binding = 0, set = 0) uniform accelerationStructureEXT tlas;
layout(binding = 1, set = 0, rgba32f) uniform image2D resultImage;

layout(binding = 2, set = 0, scalar) buffer Vertices
{
	vec3 vertices[];
};
layout(binding = 3, set = 0, scalar) buffer Indices
{
	uint indices[];
};
layout(binding = 4, set = 0, scalar) buffer Colors
{
	vec3 colors[];
};

void main()
{
	ivec2 loc = ivec2(gl_GlobalInvocationID.xy);
	
	ivec2 size = imageSize(resultImage);
	ivec4 imageExtent = { 0, 0, size[0], size[1] };
	
	const vec3 cameraOrigin = vec3(0.0, 1.0, 5.5);
	const float fovQ = 0.414214; // tan(0.5 * 45 Degrees)
	vec3 rayOrigin = cameraOrigin;
	 
    const vec2 pixelPosition = vec2(loc) + vec2(0.5);
	const vec2 lam = (2.0 * pixelPosition - vec2(size) ) / size.x;
	vec3 forward = vec3(0.0, 0.0, -1.0);
    vec3 rayDirection = forward + vec3(fovQ * lam.x, -fovQ * lam.y, 0.0);
	
	vec4 result = vec4(0.0);
	
	rayQueryEXT rayQuery;
	rayQueryInitializeEXT(
		rayQuery,
		tlas,
		gl_RayFlagsOpaqueEXT,
		0xFF,
		rayOrigin,
		0.0,
		rayDirection,
		10000.0);
	while(rayQueryProceedEXT(rayQuery))
	{
	}
	
	if(rayQueryGetIntersectionTypeEXT(rayQuery, true) == gl_RayQueryCommittedIntersectionTriangleEXT)
	{
		const int primitiveID = rayQueryGetIntersectionPrimitiveIndexEXT(rayQuery, true);
		
		result.xyz = colors[primitiveID];
	}
	result.a = 1.0;
	
	if(loc.x >= imageExtent[0] && loc.y >= imageExtent[1] 
		&& loc.x < imageExtent[2] && loc.y < imageExtent[3])
	{
		imageStore(resultImage, loc, result);
	}
}