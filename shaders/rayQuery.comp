#version 460
#extension GL_EXT_ray_query : require
#extension GL_EXT_scalar_block_layout : require
#extension GL_EXT_nonuniform_qualifier : require

const float Pi = 3.14159265358979323846;
const float InvPi = 0.318309886183790671;

struct Material {
	vec3 emission;
	float specular;
};

layout(local_size_x = 4, local_size_y = 4, local_size_z = 1) in;

layout(binding = 0, set = 0) uniform accelerationStructureEXT tlas;

layout(binding = 1, set = 0, scalar) buffer Vertices
{
	vec3 vertices[];
};
layout(binding = 2, set = 0, scalar) buffer TextureCoordinates
{
	vec2 textureCoordinates[];
};
layout(binding = 3, set = 0, scalar) buffer Indices
{
	uint indices[];
};

layout(binding = 4, set = 0, scalar) buffer MaterialIndices
{
	uint materialIndices[];
};

layout(binding = 5, set = 0, scalar) buffer Materials
{
	Material materials[];
};

// https://github.com/SaschaWillems/Vulkan/blob/master/examples/descriptorindexing/descriptorindexing.cpp
// https://github.com/SaschaWillems/Vulkan/tree/master/data/shaders/glsl/descriptorindexing

layout(binding = 6, set = 0) uniform sampler2D albedoTextures[];
layout(binding = 7, set = 0) uniform sampler2D metallicTextures[];
layout(binding = 8, set = 0) uniform sampler2D roughnessTextures[];

layout(binding = 9, set = 0, scalar) buffer RandomInputState
{
	uint randomInputState[];
};

layout(binding = 10, scalar) uniform Camera {
	vec3 position;
	float fovSlope;
	vec3 forward;
	vec3 right;
	vec3 up;
} camera;

layout(binding = 11, set = 0, rgba32f) uniform image2D colorImage;
layout(binding = 12, set = 0, rgba32f) uniform image2D normalImage;
layout(binding = 13, set = 0, rgba32f) uniform image2D albedoImage;

layout( push_constant ) uniform PushConstants // guarantueed to be 128 bytes
{
	int nSamples;
};


vec3 cameraRay(vec2 pixelPosition, vec2 frameSize){
	const vec2 lam = (2.0 * pixelPosition - vec2(frameSize) ) / frameSize.x;
	vec3 rayDirection = camera.forward + camera.right * (camera.fovSlope * lam.x) + camera.up * (-camera.fovSlope * lam.y);
	rayDirection = normalize(rayDirection);
	return rayDirection;
}

struct HaltonSequence1 {
	int b;
	int n;
	int d;
};
HaltonSequence1 HaltonSequence1Init(int b){
	HaltonSequence1 result;
	result.b = b;
	result.n = 0;
	result.d = 1;
	return result;
}
float haltonSequence1Update(inout HaltonSequence1 seq){
	int x = seq.d - seq.n;
	if (x == 1)
	{
		seq.n = 1;
		seq.d *= seq.b;
	}
	else
	{
		int y = seq.d / seq.b;
		while (x <= y)
		{
			y /= seq.b;
		}
		seq.n = (seq.b + 1) * y - x;
	}
	return float(seq.n) / seq.d;
}
struct HaltonSequence2 {
	HaltonSequence1 s1;
	HaltonSequence1 s2;
};
HaltonSequence2 HaltonSequence2Init(){
	HaltonSequence2 result;
	result.s1 = HaltonSequence1Init(2);
	result.s2 = HaltonSequence1Init(3);
	return result;
}
vec2 HaltonSequence2Update(inout HaltonSequence2 seq){
	vec2 result;
	result.x = haltonSequence1Update(seq.s1);
	result.y = haltonSequence1Update(seq.s2);
	return result;
}

struct RNG {
	uint s1;
	uint s2;
	uint s3;
	uint b;
};

// [Maximally equidistributed combined Tausworthe generators, Pierre Lâ€™Ecuyer](https://www.ams.org/journals/mcom/1996-65-213/S0025-5718-96-00696-5/)
uint QuickTausInit(uint k, uint q, uint seed){
	uint r = 32 - k;
	uint mask = uint(0xFFFFFFFF) >> r;
	uint A = seed & mask;
	uint B = (((A << q) ^ A) >> k);
	A = A ^ B;
	return A;
}
void QuickTausUpdate(inout uint A, inout uint B, uint k, uint q, uint kMinusS, uint C, uint s)
{
	B = (((A << q) ^ A) >> kMinusS);
	A = (((A & C) << s) ^ B);
}

RNG RNGInit(uint seed0, uint seed1, uint seed2){
	RNG result;
	result.s1 = QuickTausInit(31, 13, seed0);
	result.s2 = QuickTausInit(29, 2, seed1);
	result.s3 = QuickTausInit(28, 3, seed2);
	result.b = 0;
	return result;
}
uint RNGUpdate(inout RNG rng)
{
	QuickTausUpdate(rng.s1, rng.b, 31, 13, 19, 4294967294, 12);
	QuickTausUpdate(rng.s2, rng.b, 29, 2, 25, 4294967288, 4);
	QuickTausUpdate(rng.s3, rng.b, 28, 3, 11, 4294967280, 17);
	return rng.s1 ^ rng.s2 ^ rng.s3;
}
float uniform01f(inout RNG rng){
	uint randomNumber = RNGUpdate(rng);
	return randomNumber * 2.3283064365386962890625e-10; // 2^-32
}

vec3 orthonormalized(vec3 v1Normalized, vec3 v2)
{
	vec3 result = v2 - dot(v2, v1Normalized) * v1Normalized;
	return normalize(result);
}

vec3 anyOrthonormal(vec3 v1Normalized)
{
	if (abs(v1Normalized.x) < 0.7f)
	{
		return orthonormalized(v1Normalized, vec3(1.0f, 0.0f, 0.0f));
	}
	else
	{
		return orthonormalized(v1Normalized, vec3(0.0f, 1.0f, 0.0f));
	}
}
vec3 reflectAcross(vec3 outgoing, vec3 N)
{
	return reflect(-outgoing, N); // -outgoing + 2.0f * dot(N, outgoing) * N;
}

float normSq(vec3 v){ return dot(v, v); }


vec3 smallestRotationBetweenTwoVectors(vec3 vFrom, vec3 vTo, vec3 x){
	float cosAngle = dot(vFrom, vTo);
	float onePlusCosAngle = 1.0 + cosAngle;
	// v_rot = x * cos(angle) + (k sin(angle) cross x + (k sin(angle) )	( (k sin(angle) ) dot x ) / (1 + cos(angle))
	vec3 kSinAngle = cross(vFrom, vTo);
	vec3 kOrthogonal = anyOrthonormal(vFrom); // find rotation axis so we don't invert volume
	bool inversion = abs(onePlusCosAngle) <= 1e-5;
	float a = inversion ? -1.0 : cosAngle;
	vec3 b = inversion ? vec3(0.0) : kSinAngle;
	vec3 c = inversion ? kOrthogonal : kSinAngle;
	vec3 d = inversion ? (kOrthogonal * 2.0) : (kSinAngle / onePlusCosAngle);
	return x * a + cross(b, x) + c * dot(d, x);
}

vec3 sampleHemisphereCosImportance(inout RNG rng, vec3 normal, out float pDensity)
{
	vec3 dir;
	float costheta;
	do
	{
		float xi1 = uniform01f(rng);
		float xi2 = uniform01f(rng);

		float phi = 2.0 * Pi * xi2;
		costheta = sqrt(xi1);
		float sintheta = sqrt(1.0 - xi1); // sqrt(1.0f - costheta * costheta);
		float cosphi = cos(phi);
		float sinphi = sin(phi); // you cannot use sqrt(1 - cosphi*cosphi) here you are gonna loose the sign
		vec3 rv = vec3(sintheta * cosphi, sintheta * sinphi, costheta);

		dir = smallestRotationBetweenTwoVectors( vec3(0.0, 0.0, 1.0), normal, rv);
		dir = normalize(dir);
		costheta = dot(dir, normal);
	} while (costheta <= 0.0f); // stay clear from numerical mistakes

	pDensity = InvPi * costheta;
	return dir;
}
float evaluateHemisphereCosImportancePDF(vec3 normal, vec3 direction)
{
	float cosTheta = dot(normal, direction);
	if (cosTheta < 0.0f) return 0.0f;
	return InvPi * cosTheta;
}

struct SurfaceInteraction {
	int primitiveID;
	vec3 x;
	vec3 normalGeometric;
	vec2 uv;
	vec2 uvInverted;
	vec3 tangent;
	vec3 bitangent;
	vec3 normalShadingDefault;
};
SurfaceInteraction getSurfaceInteraction(rayQueryEXT rayQuery){
	SurfaceInteraction result;
	
	result.primitiveID = rayQueryGetIntersectionPrimitiveIndexEXT(rayQuery, true);
	vec2 barycentrics = rayQueryGetIntersectionBarycentricsEXT(rayQuery, true);
	float b0 = 1.0 - barycentrics[0] - barycentrics[1];
	
	uint vtxIdx0 = indices[3 * result.primitiveID];
	uint vtxIdx1 = indices[3 * result.primitiveID + 1];
	uint vtxIdx2 = indices[3 * result.primitiveID + 2];

	vec3 v0 = vertices[vtxIdx0];
	vec3 v1 = vertices[vtxIdx1];
	vec3 v2 = vertices[vtxIdx2];
	
	vec2 uv0 = textureCoordinates[3 * result.primitiveID];
	vec2 uv1 = textureCoordinates[3 * result.primitiveID + 1];
	vec2 uv2 = textureCoordinates[3 * result.primitiveID + 2];
	
	result.x = b0 * v0 + barycentrics[0] * v1 + barycentrics[1] * v2;
	result.uv = b0 * uv0 + barycentrics[0] * uv1 + barycentrics[1] * uv2;
	result.uvInverted = vec2(result.uv.x, 1.0 - result.uv.y);
	
	vec3 m = cross(v1 - v0, v2 - v0);
	result.normalGeometric = normalize(m);
	
	result.tangent = anyOrthonormal(result.normalGeometric);
	result.bitangent = cross(result.normalGeometric, result.tangent);
	
	result.normalShadingDefault = ;
	
	return result;
}

vec3 getEmissionRadiance(vec3 wo, vec3 normal, Material material){
	return dot(wo, normal) >= 0.0 ? material.emission * InvPi : vec3(0.0);
}


struct MaterialEvalResult
{
	vec3 fDiffuse;
	vec3 fSpecular;
	vec3 normalShading;
};
struct SampleResult
{
	bool outside;
	vec3 direction;
	vec3 throughputDiffuse;
	vec3 throughputSpecular;
	float pdfOmega;
};


MaterialEvalResult MaterialEvalResultInit(vec3 d, vec3 s, vec3 n)
{
	MaterialEvalResult result;
	result.fDiffuse = d;
	result.fSpecular = s;
	result.normalShading = n;
	return result;
}

float PrincipledBRDFcomputeAlpha(float roughness)
{
	float alpha = roughness * roughness;
	if (alpha < 1e-2f && alpha != 0.0f)
	{
		alpha = 1e-2f;
	}
	return alpha;
}


float square(float f){ return f*f; }


float DGGX(float nh, float th, float bh, float alpha_t, float alpha_b)
{
	float D = float(InvPi) / (alpha_t * alpha_b * square(square(th / alpha_t) + square(bh / alpha_b) + square(nh)));
	return D;
}

float smithGGX(float nv, float tv, float bv, float alpha_t, float alpha_b)
{
	float lambda = 0.5f * ( sqrt(1.0f + (square(alpha_t * tv) + square(alpha_b * bv))/square(nv))	- 1.0f);
	return 1.0f / (1.0f + lambda);
}

// see "Sampling the GGX Distribution of Visible Normals" Eric Heitz for an explanation
// and https://simonstechblog.blogspot.com/2020/01/note-on-sampling-ggx-distribution-of.html
// and https://schuttejoe.github.io/post/ggximportancesamplingpart2/
vec3 sampleGGXVNDF(vec3 wOut, float alphaX, float alphaY, float xi1, float xi2)
{
	vec3 Vh = normalize(vec3(alphaX * wOut[0], alphaY * wOut[1], wOut[2]));

	// compute frame
	vec3 X = vec3(1.0f, 0.0f, 0.0f);
	vec3 Z = vec3(0.f, 0.f, 1.0f);
	vec3 T1 = cross(Vh, Z);
	if (normSq(T1) < 1e-12f) T1 = X;
	else T1 = normalize(T1);
	vec3 T2 = cross(T1, Vh);

	float r = sqrt(xi1);
	float a = 1.0f / (1.0f + Vh[2]);
	float phi = float(Pi) * ((xi2 < a) ? (xi2 / a) : (1.0f + (xi2 - a) / (1.0f - a)));
	float t1 = r * cos(phi);
	float t2 = r * sin(phi) * (xi2 < a ? 1.0f : Vh[2]);
	float t3 = sqrt(max(0.0f, 1.0f - t1 * t1 - t2 * t2));
	vec3 Nh = t1 * T1 + t2 * T2 + t3 * Vh;
	vec3 Ne = normalize(vec3(alphaX * Nh[0], alphaY * Nh[1], max(0.0f, Nh[2])));

	return Ne;
}
vec3 sampleGGXVNDFGlobal(inout RNG rng, vec3 normal, float alpha_t, float alpha_b, vec3 tangent, vec3 bitangent, vec3 dir1, out float pDensity)
{
	if (dot(dir1, normal) <= 0.0f)
	{
		
		pDensity = 0.0f;
		return -normal;
	}

	vec3 NeGlobal;
	do
	{
		vec3 Ve = vec3(dot(tangent, dir1), dot(bitangent, dir1), dot(normal, dir1));
		vec3 Ne = sampleGGXVNDF(Ve, alpha_t, alpha_b, uniform01f(rng), uniform01f(rng));

		NeGlobal = tangent * Ne[0] + bitangent * Ne[1] + normal * Ne[2];
		NeGlobal = normalize(NeGlobal); // TODO move out of loop
	} while (dot(NeGlobal, dir1) <= 0.0f);

	vec3 dir2 = reflectAcross(dir1, NeGlobal);
	dir2 = normalize(dir2); //TODO remove?
	// V = dir1, N = H
	float G1 = smithGGX(dot(normal, dir1), dot(tangent, dir1), dot(bitangent, dir1), alpha_t, alpha_b);
	float D_ggx = DGGX(dot(normal, NeGlobal), dot(tangent, NeGlobal), dot(bitangent, NeGlobal), alpha_t, alpha_b);
	float pDensityH = G1 * dot(dir1, NeGlobal) * D_ggx / dot(dir1, normal);
	pDensity = pDensityH / (1e-7f + 4.0f * abs(dot(dir1, NeGlobal)));
	return dir2;
}
float sampleGGXVNDFGlobalDensity(vec3 normal, float alpha_t, float alpha_b, vec3 tangent, vec3 bitangent, vec3 dir1, vec3 dir2)
{
	if (dot(dir1, normal) <= 0.0f)
	{
		
		return 0.0f;
	}
	vec3 NeGlobal = normalize(dir1 + dir2);
	float G1 = smithGGX(dot(normal, dir1), dot(tangent, dir1), dot(bitangent, dir1), alpha_t, alpha_b);
	float D_ggx = DGGX(dot(normal, NeGlobal), dot(tangent, NeGlobal), dot(bitangent, NeGlobal), alpha_t, alpha_b);
	float pDensityH = G1 * max(0.0f, dot(dir1, NeGlobal)) * D_ggx / dot(dir1, normal);
	return pDensityH / (1e-7f + 4.0f * abs(dot(dir1, NeGlobal)));
}
float signSide(float dotNW) {
	return dotNW < 0.0f ? -1.0f : 1.0f;
}

bool sideOutside(float dotNW) {
	return dotNW >= 0.0f;
}

float computeNormalScale(vec3 wi, vec3 normalShading, vec3 normalGeometric) {
	return abs(dot(wi, normalShading)) / (1e-7f + abs(dot(wi, normalGeometric)));
}

vec3 PrincipledBRDFgetShadingNormal(SurfaceInteraction interaction, vec3 wo, float dotNgWo)
{
	float sideNgWo = signSide(dotNgWo);
	vec3 normalShading;
		normalShading = interaction.normalShadingDefault;
	float sideNsWo = signSide(dot(normalShading, wo));
	if (sideNgWo != sideNsWo)
	{
		normalShading = interaction.normalGeometric; // this is not consistent but good enough for the hack called normal map
	}
	// here we guarantuee signSide(normalShading, wo) == signSide(interaction.normalGeometric, wo)
	// but now we flip it according to normalGeometric:
	normalShading *= sideNgWo;
	return normalShading;
}

void PrincipledBRDFcomputeProbability(float metallicHit, float specularHit, out float diffSpecMix, out float pProbablitySpec)
{
	diffSpecMix = min(1.0f - metallicHit, 1.0f - 0.5f * specularHit); // we want this to be zero when metallic and one when specular = 0
	pProbablitySpec = 1.0f - diffSpecMix;
}
void PrincipledBRDFcomputeAnisotropyParameters(SurfaceInteraction interaction, vec3 normalShading, float alpha, float anisotropyHit, out float alpha_t, out float alpha_b, out vec3 tangent, out vec3 bitangent)
{
	float aspect = sqrt(1.0f - 0.9f * anisotropyHit);
	alpha_t = alpha / aspect;
	alpha_b = alpha * aspect;
	tangent = smallestRotationBetweenTwoVectors(interaction.normalGeometric, normalShading, interaction.tangent);
	bitangent = smallestRotationBetweenTwoVectors(interaction.normalGeometric, normalShading, interaction.bitangent);
}

vec3 PrincipledBRDFevaluateDiffuse(
	vec3 albedoHit, float diffuseSpecMix){
	return albedoHit * float(InvPi) * diffuseSpecMix;
}
vec3 PrincipledBRDFevaluateSpecular(
	vec3 albedoHit, float metallicHit, float specularHit,
	float roughnessHit, float anisotropyHit,
	vec3 wo, vec3 wi,
	float alpha,
	float alpha_t, float alpha_b,
	vec3 tangent, vec3 bitangent,
	vec3 normalShading, float diffuseSpecMix){
	
	vec3 h = normalize(wo + wi);
	float lh = abs(dot(wi, h));
	vec3 Ks = vec3(1.0);
	vec3 F0 = mix(Ks, albedoHit, metallicHit);

	vec3 FH = F0 + (vec3(1.0) - F0) * pow(1.0f - lh, 5.0);

	float nh = dot(normalShading, h);
	
	float nv = abs(dot(normalShading, wo));
	float nl = abs(dot(normalShading, wi));
	float Go = smithGGX(nv, dot(tangent, wo), dot(bitangent, wo), alpha_t, alpha_b);
	float Gi = smithGGX(nl, dot(tangent, wi), dot(bitangent, wi), alpha_t, alpha_b);
	float G = Go * Gi;
	
	float D_ggx;

	if (alpha == 0.0f)
	{
		// D_GGX explodes for alpha= 0 and nh = 1
		// we can find this by using importance sample formula and then let alpha go to zero?, G is always 1 in that case
		// => \int F D G/ (4 nv nl) dl ~= 1/N \sum_i	F D Gi Go/ (4 nv nl_i	p(l_i) )
		//					 ~= 1/N \sum_i	F / nv ~=	 F / nv for alpha = 0
		D_ggx = abs(abs(nh) - 1.0f) < 1e-3f ? 4.0f * nl : 0.0f;
	}
	else
	{
		D_ggx = DGGX(nh, dot(tangent, h), dot(bitangent, h), alpha_t, alpha_b);
	}

	vec3 result = FH * (D_ggx * G / abs(1e-7f + 4.0f * nv * nl) * (1.0f - diffuseSpecMix));
	return result;
}

SampleResult PrincipledBRDFsample(inout RNG rng, SurfaceInteraction interaction, vec3 wo)
{
	SampleResult result;

	//assert(evalFlag != ShaderEvalFlagNONE); // no distribution to sample

	float dotNgWo = dot(interaction.normalGeometric, wo);
	vec3 normalShading = PrincipledBRDFgetShadingNormal(interaction, wo, dotNgWo);
	float dotNsWo = dot(normalShading, wo);

	vec3 albedoHit = albedo->evaluate(interaction);
	float roughnessHit = roughness->evaluate(interaction);
	float alpha = computeAlpha(roughnessHit);
	float metallicHit = metallic->evaluate(interaction);
	float specularHit = this->specular;
	float anisotropyHit = this->anisotropy;
	float transmissionHit = transmission;

	float indexOfRefractionOutside = getOutsideIOR();
	float indexOfRefractionMat;
	int wavelength;
	if (varyIOR)
	{
		wavelength = result.lightRay.getWavelength(rng, abs(albedoHit));
		indexOfRefractionMat = getIndexOfRefraction(wavelength);
	}
	else
	{
		wavelength = -1;
		indexOfRefractionMat = getIndexOfRefraction(0);
	}

	result.outside = sideOutside(dotNgWo);
	float indexOfRefraction_o = result.outside ? indexOfRefractionOutside : indexOfRefractionMat;
	float indexOfRefraction_refr_o = result.outside ? indexOfRefractionMat : indexOfRefractionOutside;
	
	ProbabilityResult probabilityResult = computeProbability(metallicHit, specularHit, transmission, dotNsWo, indexOfRefraction_o, indexOfRefraction_refr_o, evalFlag);

	if (probabilityResult.noStrategy) {
		result.direction = vec3(1.0f, 0.0f, 0.0f);
		result.throughputDiffuse = vec3(0.0);
		result.throughputConcentrated = vec3(0.0);
		result.pdfOmega = 0.0f;
		return result;
	}

	// we just put the same Fresnel term in for all wavelengths and then mask the output:
	vec3 FDaccurateVector = vec3Fill(probabilityResult.FDaccurate);
	vec3 wavelengthMask = vec3(1.0);
	if (wavelength != -1) {
		wavelengthMask = vec3(0.0);
		wavelengthMask[wavelength] = 1.0f;
	}

	float alpha_t, alpha_b;
	vec3 tangent, bitangent;
	computeAnisotropyParameters(interaction, normalShading, alpha, alpha_t, alpha_b, tangent, bitangent);

	// pSpecStr = proability to sample using Specular Strategy
	// p_diff = probability density of diffuse sampling scheme
	// p_spec = probability density of specular sampling scheme
	//F = f L cos(omega) / p(omega)	, omega ~ uniform
	//E[F] = \int f L cos(omega) / p(omega) * p(omega) domega = \int f L cos(omega) domega
	//F' = {
	//			f L cos(omega) / (pSpecStr p_spec(omega) + (1 - pSpecStr) p_diff(omega)) , omega ~ p(spec)		 xi < pSpecStr
	//			f L cos(omega) / (pSpecStr p_spec(omega) + (1 - pSpecStr) p_diff(omega)), omega ~ p(diffuse) xi >= pSpecStr
	//		 }
	//E[F'] = pSpecStr \int f L cos(omega) / (pSpecStr p_spec(omega) + (1 - pSpecStr) p_diff(omega))	p_spec(omega) domega + (1 - pSpecStr) \int f L cos(omega) / (pSpecStr p_spec(omega) + (1 - pSpecStr) p_diff(omega)) p_diff(omega) domega
	//			 = \int f L cos(omega)	(pSpecStr	p_spec(omega) + (1 - pSpecStr)p_diff(omega)) / (pSpecStr p_spec(omega) + (1 - pSpecStr) p_diff(omega))) domega
	//			 = \int f L cos(omega) domega = E[F]
	
	MaterialEvalResult evalResult = MaterialEvalResult(vec3(0.0), vec3(0.0), normalShading);

	// using defines here instead of enums to support glsl
#define PBRDF_STRATEGY_DIFFUSE 1u
#define PBRDF_STRATEGY_SPECULAR 2u
#define PBRDF_STRATEGY_REFRACTIVE 3u

	float xi = uniform01f(rng); // xi \in [0, 1)
	uint32_t strategy = xi < probabilityResult.pRefractiveStrategy ? PBRDF_STRATEGY_REFRACTIVE : ( xi < (probabilityResult.pRefractiveStrategy + probabilityResult.pSpecularStrategy) ? PBRDF_STRATEGY_SPECULAR : PBRDF_STRATEGY_DIFFUSE);
	if (strategy == PBRDF_STRATEGY_SPECULAR)
	{

		if (alpha == 0.0f) // delta distribution; need to keep wierd fake measure
		{
			//F' = {
			//			(f_specular L cos(omegaSpec)) / pSpecStr, omega = omegaSpec		 xi < pSpecStr
			//			f_diffuse L cos(omega) / ((1 - pSpecStr) p_diff), omega ~ p_diff xi >= pSpecStr
			//		 }
			//E[F'] = pSpecStr f_specular(omega) L(omega) cos(omegaSpec) / pSpecStr + (1 - pSpecStr) \int f_diffuse L cos(omega) / ((1 - pSpecStr) pDiffuse) pDiffuse(omega) domega
			//			 = L f_specular(omega_specular) cos(omega_specular) + \int L cos(omega) f_diffuse(omega) domega
			//			 = \int	L cos(omega) f_specular dirac_specular(omega) domega + \int L cos(omega) f_diffuse domega
			//			 = \int	L cos(omega) (f_specular dirac_specular(omega)	+	f_diffuse) domega
			result.direction = reflectAcross(wo, normalShading);
			result.pdfOmega = 1e12f; // this is the probability for MIS , we could also tell it directly that it's a dirac delta but this should work to working precision
			vec3 wi = result.direction;
			float normalScale = computeNormalScale(wi, normalShading, interaction.normalGeometric);
			evalResult.fDiffuse = vec3(0.0);
			evalResult.fConcentrated = 1e12f / probabilityResult.pSpecularStrategy * PrincipledBRDFevaluateConcentrated(
				albedoHit, metallicHit, specularHit,
				roughnessHit, anisotropyHit, transmission,
				wo, result.direction,
				alpha,
				alpha_t, alpha_b,
				tangent, bitangent,
				normalShading, normalScale, true, false, FDaccurateVector);
		}
		else
		{
			float pdfSpec;
			result.direction = sampleGGXVNDFGlobal(rng, normalShading, alpha_t, alpha_b, tangent, bitangent, wo, &pdfSpec);
			float pdfDiffuse = evaluateHemisphereCosImportancePDF(normalShading, result.direction);

			result.pdfOmega = probabilityResult.pSpecularStrategy * pdfSpec + probabilityResult.pDiffuseStrategy * pdfDiffuse;
			vec3 wi = result.direction;
			float normalScale = computeNormalScale(wi, normalShading, interaction.normalGeometric);
			evalResult.fDiffuse = PrincipledBRDFevaluateDiffuse(albedoHit, normalScale, metallicHit, specularHit, transmission);
			evalResult.fConcentrated = PrincipledBRDFevaluateConcentrated(
				albedoHit, metallicHit, specularHit,
				roughnessHit, anisotropyHit, transmission,
				wo, result.direction,
				alpha,
				alpha_t, alpha_b,
				tangent, bitangent,
				normalShading, normalScale, false, false, FDaccurateVector);
		}
	}
	else if(strategy == PBRDF_STRATEGY_DIFFUSE)
	{
		float pdfDiffuse;
		result.direction = sampleHemisphereCosImportance(rng, normalShading, &pdfDiffuse);
		vec3 wi = result.direction;
		float normalScale = computeNormalScale(wi, normalShading, interaction.normalGeometric);

		if (alpha == 0.0f) // delta distribution; need to keep wierd fake measure
		{
			result.pdfOmega = probabilityResult.pDiffuseStrategy * pdfDiffuse;
			evalResult.fDiffuse = PrincipledBRDFevaluateDiffuse(albedoHit, normalScale, metallicHit, specularHit, transmission);
			evalResult.fConcentrated = vec3(0.0);
		}
		else
		{
			float pdfSpec = sampleGGXVNDFGlobalDensity(normalShading, alpha_t, alpha_b, tangent, bitangent, wo, result.direction);
			result.pdfOmega = probabilityResult.pSpecularStrategy * pdfSpec + (1.0f - probabilityResult.pSpecularStrategy) * pdfDiffuse;
			evalResult.fDiffuse = PrincipledBRDFevaluateDiffuse(albedoHit, normalScale, metallicHit, specularHit, transmission);
			evalResult.fConcentrated = PrincipledBRDFevaluateConcentrated(
				albedoHit, metallicHit, specularHit,
				roughnessHit, anisotropyHit, transmission,
				wo, result.direction,
				alpha,
				alpha_t, alpha_b,
				tangent, bitangent,
				normalShading, normalScale, false, false, FDaccurateVector);
		}
	}
	else {
		// refraction: switch outside
		result.outside = !result.outside;
		result.pdfOmega = 1e12f;
		evalResult.fDiffuse = vec3(0.0);
		if (!probabilityResult.refractionPossible) {
			evalResult.fConcentrated = vec3(0.0);
			result.direction = vec3(1.0f, 0.0f, 0.0f);
		}
		else {
			vec3 wi = computeRefractionDirectionFromAngles(wo, normalShading, indexOfRefraction_o / indexOfRefraction_refr_o, dotNsWo, probabilityResult.cosT);
			result.direction = wi;
			float scale = adjoint ? 1.0f : square(indexOfRefraction_o) / square(indexOfRefraction_refr_o); // See "Non-symmetric Scattering in Light Transport Algorithms" the eq. after eq. 10
			float fc = 1e12f / probabilityResult.pRefractiveStrategy * scale * (1.0f - probabilityResult.FDaccurate) / abs(dot(result.direction, interaction.normalGeometric));
			evalResult.fConcentrated = fc * wavelengthMask;
		}
	}

	float m = abs(dot(result.direction, interaction.normalGeometric)) / result.pdfOmega;
	result.throughputDiffuse = evalResult.fDiffuse * m;
	result.throughputConcentrated = evalResult.fConcentrated * m;

	//assertUnitLength(result.direction);
	//assertFinite(result.throughputDiffuse);
	//assertFinite(result.throughputConcentrated);
	//assertFinite(result.pdfOmega);
	return result;
}

void main()
{
	ivec2 size = imageSize(colorImage);
	ivec2 loc = ivec2(gl_GlobalInvocationID.xy);
	uint pixelLinearIndex = size[0] * loc[1] + loc[0];
	
	uint seed0 = randomInputState[3 * pixelLinearIndex + 0];
	uint seed1 = randomInputState[3 * pixelLinearIndex + 1];
	uint seed2 = randomInputState[3 * pixelLinearIndex + 2];
	
	RNG rng = RNGInit(seed0, seed1, seed2);
	
	ivec4 imageExtent = { 0, 0, size[0], size[1] };
	
	if(loc.x >= imageExtent[0] && loc.y >= imageExtent[1] 
		&& loc.x < imageExtent[2] && loc.y < imageExtent[3])
	{
		//vec3 sumColorSamples = imageLoad(colorImage, loc).xyz;
		//vec3 sumNormalSamples = imageLoad(normalImage, loc).xyz;
		//vec3 sumAlbedoSamples = imageLoad(albedoImage, loc).xyz;
		vec3 sumColorSamples = vec3(0.0);
		vec3 sumNormalSamples = vec3(0.0);
		vec3 sumAlbedoSamples = vec3(0.0);
		
		HaltonSequence2 pixelPositionSeq = HaltonSequence2Init();
		for(int sampleIdx=0; sampleIdx < nSamples; sampleIdx++){
		
			vec3 colorSample = vec3(0.0);
			vec3 throughput = vec3(1.0);
			
			const vec2 pixelPosition = vec2(loc) + HaltonSequence2Update(pixelPositionSeq);
			vec3 rayOrigin = camera.position;
			vec3 rayDirection = cameraRay(pixelPosition, size);
			
			for(int depth = 0; depth < 10; depth++){
				
				rayQueryEXT rayQuery;
				rayQueryInitializeEXT(
					rayQuery,
					tlas,
					gl_RayFlagsOpaqueEXT,
					0xFF,
					rayOrigin,
					1e-5,
					rayDirection,
					10000.0);
				while(rayQueryProceedEXT(rayQuery))
				{
				}
				
				if(rayQueryGetIntersectionTypeEXT(rayQuery, true) == gl_RayQueryCommittedIntersectionTriangleEXT)
				{
					vec3 wo = -rayDirection;
					
					SurfaceInteraction surfaceInteraction = getSurfaceInteraction(rayQuery);
					uint materialIdx = materialIndices[surfaceInteraction.primitiveID];
					Material material = materials[materialIdx];
					
					vec3 albedoHit = texture(albedoTextures[materialIdx], surfaceInteraction.uvInverted).xyz;
					
					if(depth == 0){
						sumNormalSamples += surfaceInteraction.normalGeometric;
						sumAlbedoSamples += albedoHit;
					}
					
					vec3 emission = getEmissionRadiance(wo, surfaceInteraction.normalGeometric, material);
					colorSample += throughput * emission;
					if(dot(emission,emission) > 0.0) break;
					
					const float metallicHit = texture(metallicTextures[materialIdx], surfaceInteraction.uvInverted).x;
					const float roughnessHit = texture(roughnessTextures[materialIdx], surfaceInteraction.uvInverted).x;
					const float specularHit = material.specular;
					const float anisotropyHit = 0.0;
					const float outsideIOR = 1.0;
					
					SampleResult sampleResult = PrincipledBRDFsample(
						rng, surfaceInteraction, albedoHit,
						metallicHit, specularHit, roughnessHit, anisotropyHit,
						wo, outsideIOR);
					
					vec3 throughputHit = sampleResult.throughputDiffuse + sampleResult.throughputSpecular;
					
					throughput *= throughputHit;
					
					rayOrigin = surfaceInteraction.x + 1e-4 * surfaceInteraction.normalGeometric;
					rayDirection = sampleResult.direction;
				} else {
					break;
				}
				
				float rouletteP = depth > 2 ? 0.30 : 0.0;
				if(uniform01f(rng) < rouletteP){
					break;
				}
				throughput /= (1.0 - rouletteP);
			}
			
			
			sumColorSamples += colorSample;
		}
		
		imageStore(colorImage, loc, vec4(sumColorSamples, 1.0));
		imageStore(normalImage, loc, vec4(sumNormalSamples, 1.0));
		imageStore(albedoImage, loc, vec4(sumAlbedoSamples, 1.0));
	}
}